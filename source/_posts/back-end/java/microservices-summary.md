---
title: 微服务架构总结
date: 2020-03-29 17:09:00
categories: Java
tags:
  - MicroServices
  - SpringCloud
---

为什么需要微服务？从谷歌的搜索指数来看，微服务的热度在进入 2017 年后突然爆发，国内各大会议和论坛的相关讨论也如雨后春笋般层出不穷，各大一线互联网公司也纷纷将这一技术引入并在实际业务中落地。

<!--more-->

## 到底什么是微服务？

微服务的概念最早是在 2014 年由 Martin Fowler 和 James Lewis 共同提出，他们定义了微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。

### 单体应用

早些年，各大互联网公司的应用技术栈大致可分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis/Hibernate + Tomcat）两大流派。无论是 LAMP 还是 MVC，都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。

以 MVC 架构为例，业务通常是通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。

然而随着业务规模的不断扩大，团队开发人员的不断扩张，单体应用架构就会开始出现问题：

- **部署效率低下：**当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要 10 分钟以上。这也经常被新加入的同学吐槽说，部署测试一次的时间，都可以去楼下喝杯咖啡了；
- **团队协作开发成本高：**早期在团队开发人员只有两三个人的时候，协作修改代码，最后合并到同一个 master 分支，然后打包部署，尚且可控。但是一旦团队人员扩张，超过 5 人修改代码，然后一起打包部署，测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有相关的开发人员又都得参与其中，效率低下，开发成本极高；
- **系统高可用性差：**因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。比如我经常遇到的一个问题，某段代码不断在内存中创建大对象，并且没有回收，部署到线上运行一段时间后，就会造成 JVM 内存泄露，异常退出，那么部署在同一个 JVM 进程中的所有服务都不可用，后果十分严重；
- **线上发布变慢：**特别是对于 Java 应用来说，一旦代码膨胀，服务启动的时间就会变长，有些甚至超过 10 分钟以上，如果机器规模超过 100 台以上，假设每次发布的步长为 10%，单次发布需要就需要 100 分钟之久。因此，急需一种方法能够将应用的不同模块的解耦，降低开发和部署成本；

想要解决上面这些问题，服务化的思想也就应运而生。

### 什么是服务化？

用通俗的话来讲，服务化就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。一般在编写业务代码时，对于一些通用的业务逻辑，会尽力把它抽象并独立成为专门的模块，因为这对于代码复用和业务理解都大有裨益。

以微博系统为例，微博既包含了内容模块，也包含了消息模块和用户模块等。其中消息模块依赖内容模块，消息模块和内容模块又都依赖用户模块。当这三个模块的代码耦合在一起，应用启动时，需要同时去加载每个模块的代码并连接对应的资源。一旦任何模块的代码出现 bug，或者依赖的资源出现问题，整个单体应用都会受到影响。

为此，首先可以把用户模块从单体应用中拆分出来，独立成一个服务部署，以 RPC 接口的形式对外提供服务。微博和消息模块调用用户接口，就从进程内的调用变成远程 RPC 调用。这样，用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。进一步的可以再把消息模块也拆分出来作为独立的模块，交由专门的团队来开发和维护。

可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。

### 什么是微服务？

从 2014 年开始，得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化，演变为今天我们所熟知的微服务。

那么微服务相比于服务化又有什么不同呢？

- **服务拆分粒度更细：**微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务；
- **服务独立部署：**每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码；
- **服务独立维护：**每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责；
- **服务治理能力要求高：**因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理；

继续以前面举的微博系统为例，可以进一步对内容模块的功能进行拆分，比如内容模块又包含了 feed 模块、评论模块和个人页模块。通过微服务化，将这三个模块变成三个独立的服务，每个服务依赖各自的资源，并独立部署在不同的服务池中，可以由不同的开发人员进行维护。当评论服务需求变更时，只需要修改评论业务相关的代码，并独立上线发布；而 feed 服务和个人页服务不需要变更，也不会受到发布可能带来的变更影响。

由此可见，微服务化给服务的发布和部署，以及服务的保障带来了诸多好处。

微服务是由单体应用进化到服务化拆分部署，后期随着移动互联网规模的不断扩大，敏捷开发、持续交付、DevOps 理论的发展和实践，以及基于 Docker 容器化技术的成熟，微服务架构开始流行，逐渐成为应用架构的未来演进方向。

总结来说，微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付的效率，并被各大互联网公司所普遍采用。

## 服务化拆分

### 服务化拆分的两种姿势

那么服务化拆分具体该如何实施呢？一个最有效的手段就是将不同的功能模块服务化，独立部署和运维。以社交 App 为例，你可以认为首页信息流是一个服务，评论是一个服务，消息通知是一个服务，个人主页也是一个服务。

这种服务化拆分方式是**纵向拆分**，是从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。

还有一种服务化拆分方式是**横向拆分**，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。

无论是首页信息流、评论、消息箱还是个人主页，都需要显示用户的昵称。假如用户的昵称功能有产品需求的变更，你需要上线几乎所有的服务，这个成本就有点高了。显而易见，如果我把用户的昵称功能单独部署成一个独立的服务，那么有什么变更我只需要上线这个服务即可，其他服务不受影响，开发和上线成本就大大降低了。

### 服务化拆分的前置条件

一般情况下，业务系统引入新技术就必然会带来架构的复杂度提升，在具体决策前，你先要认识到新架构会带来哪些新的问题，这些问题你和你的团队是否能够解决？如何解决？是自己投入人力建设，还是采用业界开源方案？

下面几个问题，是从单体应用迁移到微服务架构时必将面临也必须解决的：

- **服务如何定义：**对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。对于微服务来说，每个服务都运行在各自的进程之中，应该以何种形式向外界传达自己的信息呢？答案就是接口，无论采用哪种通讯协议，是 HTTP 还是 RPC，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值；
- **服务如何发布和订阅：**单体应用由于部署在同一个 WAR 包里，接口之间的调用属于进程内的调用。而拆分为微服务独立部署后，服务提供者该如何对外暴露自己的地址，服务调用者该如何查询所需要调用的服务的地址呢？这个时候你就需要一个类似登记处的地方，能够记录每个服务提供者的地址以供服务调用者查询，在微服务架构里，这个地方就是注册中心；
- **服务如何监控：**通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能；
- **服务如何治理：**可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一；
- **故障如何定位：**在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位；

## 微服务架构基本组件

### 服务描述

服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。

### 注册中心

有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。

注册中心的工作流程是：

- 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务；
- 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务；
- 注册中心返回服务提供者地址列表给服务消费者；
- 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者；

### 服务框架

通过注册中心，服务消费者就可以获取到服务提供者的地址，有了地址后就可以发起调用。但在发起调用之前你还需要解决以下几个问题：

- 服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？
- 数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。
- 数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 JSON 序列化、Java 对象序列化以及 Protobuf 序列化等。

### 服务监控

一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程：

- 指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心；
- 数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标；
- 数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 Dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等；

### 服务追踪

除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。

服务追踪的工作原理大致如下：

- 服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者；
- 服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递；

以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。

### 服务治理

服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。

在生产环境中，经常会遇到下面几种状况：

- **单机故障：**通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务；
- **单 IDC 故障：**你应该经常听说某某 App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 IDC 的流量到其他正常 IDC，可以避免因为单 IDC 故障引起的大批量业务受影响。
- **依赖服务不可用：**比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。

上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。

## 什么时候采用微服务架构？

有的人认为微服务比较复杂，不太适合初创应用，单块应用更简单；也有的人认为微服务是互联网架构的趋势，到底用不用微服务？什么时候用？

### 观点1:单块优先

企业应用是否要微服务化，主要看企业应用发展的阶段和规模。业务发展早期建议采用单块架构，随着业务的发展和扩张，也随着对业务领域不断深入的理解再逐步拆分解耦划出微服务架构。

![1][1]

软件技术大牛 Martin Fowler 是这个观点的支持者，他主张应用开发应该优先考虑单块 Monolith First，如果一开始就考虑微服务没办法正确把握业务领域边界的划分，所以失败风险比较高。

如果先以单块开始，就可以赢得更多时间去探索业务领域的复杂性，对业务领域的边界会有更深入的理解，这个基础上再根据业务和团队规模发展需要逐步拆分成微服务，这种方式风险比较低。

**微服务引入时机**

![2][2]

什么时候引入微服务？Martin Fowler 认为企业应用刚开始并不复杂，如果一开始就采用微服务架构，因为微服务需要基础设施这些额外的技术支持，企业就需要额外的投入，生产力反而不如单块应用。

当企业业务的复杂性和规模到达一个点，单块应用因为耦合等因素，生产力会急剧下滑，这个时候就可以考拆分成微服务。这个点需要企业综合考虑。

### 观点2:微服务优先

![3][3]

这个观点认为技术的进步使得微服务架构的门槛和成本已经大大降低了，微服务架构是当前互联网架构的首选，以前微服务架构体系不成熟，基础组件缺乏，一般企业去实施微服务架构的门槛和成本是比较高的。现在这个情况已经发生了根本性的变化，经过多年的行业实践和沉淀微服务架构已经变得成熟，开源的基础组件已经比较丰富，Netflix OSS 组件、Spring Cloud 微服务开发套餐、Docker 容器技术、Google K8s 容器云平台，一个完整的微服务生态圈已经完善了。

Netflix 开源了整个微服务技术栈，统称 Netflix OSS。开源组件包括：

- Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
- Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
- Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
- Feign：基于Ribbon和Hystrix的声明式服务调用组件；
- Zuul：API网关组件，对请求提供路由及过滤功能；

Pivotal 在 Netflix OSS 开源的基础上再封装，推出了 Spring Cloud 微服务开发套餐：

- Spring Cloud Config：集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作；
- Spring Cloud Netflix：封装了 Netflix OSS；
- Spring Cloud Bus：用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置；
- Spring Cloud Consul：基于Hashicorp Consul的服务治理组件；
- Spring Cloud Security：安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持；
- Spring Cloud Sleuth：SpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪；
- Spring Cloud Stream：轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ；
- Spring Cloud Task：用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性；
- Spring Cloud Zookeeper：基于Apache Zookeeper的服务治理组件；
- Spring Cloud Gateway：API网关组件，对请求提供路由及过滤功能；
- Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在SpringCloud 2.0中已经取代Feign成为了一等公民；

> 为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本, Brixton是第二个版本。当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个"service releases"版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。

对于传统遗留老系统，循序渐进，根据业务和团队规模逐步拆分解耦，不要为了微服务而微服务。如果是新应用，业务领域比较熟悉，可以考虑一步到位直接微服务，但也不要拆分过细，跟着业务和团队规模来。

## 微服务架构技术栈选型

Dubbo、Spring Cloud 和 K8s 是开发微服务主流的解决方案，服务框架和平台的选择是搭建微服务架构的基础，好比构建一个大厦的基建材料，它的重要性是不言而喻的。

这三个都是对同一个问题，分布式微服务开发的一个解，只不过这三家的解法、侧重点和抽象级别不一样。因为都是对同一个问题的解，这些产品当中有部分功能是重叠的，而且可能还是排他的，也就是说如果你选中了其中一家的产品，就不要随便混搭，虽然技术可以做到把它们两个甚至三个硬揉在一起，但是架构上会缺乏一致性，要同时维护多套体系，维护成本会变高。

### 微服务公共关注点

![4][4]

微服务最终的目标是实现业务价值，交付业务价值，但是为了让开发人员能够专注于业务交付，微服务需要底层基础设施支撑，这些基础设施也称为微服务的公共关注点。

### Dubbo、Spring Cloud和K8s横向比对

| | Dubbo | Spring Cloud | K8s |
| :-------------- | :----------- |:----------- |:----------- |
| 服务发现和LB | ZK/Nacos + Client | Eureka + Ribbon | Service |
| API网关 | NA | Zuul | Ingress |
| 配置管理 | Diamond/Nacos | Spring Cloud Config | ConfigMaps/Secrets |
| 容错限流 | Sentinel | Hystrix | HealthCheck/Probe/ServiceMesh |
| 日志监控 | ELK | ELK | EFK |
| Metrics监控 | Dubbo Admin/Monitor | Actuator/MicroMeter + Prometheus | Heapster+Prometheus |
| 调用链监控 | NA | SpringCloud Sleuth/Zipkin | Jaeger/Zipkin |
| 应用打包 | Jar/War | Uber Jar/War | Docker Image/Helm |
| 服务框架 | Dubbo RPC | Spring(Boot) REST | 框架无关 |
| 发布和调度 | NA | NA | Scheduler |
| 自动伸缩和自愈 | NA | NA | Scheduler/AutoScaler |
| 进程隔离 | NA | NA | Docker/Pod |
| 环境管理 | NA | NA | Namespace/Auththorization |
| 资源配额 | NA | NA | CPU/Mem Limit, Namespace Quotas |
| 流量治理 | ZK + Client | NA | ServiceMesh |

### 优劣比对

| | Dubbo | Spring Cloud | K8s |
| :-------------- | :----------- |:----------- |:----------- |
| 亮点 | 阿里背书、成熟稳定、RPC高性能、流量治理 | Netflix/Pivotal背书、社区活跃、开发体验好、抽象组件化好 | 谷歌背书、平台抽象、全面覆盖微服务关注点(发布)、语言栈无关、社区活跃 |
| 不足 | 技术较老、耦合性高、JVM only、国外社区小 | JVM only、运行耗资源 | 偏DevOps和运维、重量复杂、技术门槛高 |

Dubbo和Spring Cloud 仅仅解决了微服务基础设施的部分问题，K8s 是一个完整的微服务基础设施解决方案，被认为是未来的数据中心操作系统，云原生应用的一个标配。

**比喻：**

- Dubbo：更像是一个 PC 品牌机，一次性买好就可以用，一般不会替换内部的组件；
- Spring Cloud：更像是一个组装机，可以灵活的替换；
- K8s：Dubbo 和 Spring Cloud 是框架和组件，如果比喻建房子，这两个就是自建房，自己去买建筑材料。K8s 是个平台，开发商承建的商品房，用户拎包入住即可。

阿里讲究实用、解决实际问题、追求高性能，设计上倾向于 All in one；Pivotal 讲究抽象组件化，系统可以装配和扩展；Google 讲究体系化和平台化，抽象层次最高，更偏向云架构的思想，设计上是把应用容纳到基础设施中去，而不是倒过来让基础设施区迎合应用。

**建议：**

- 理解微服务关注点，根据企业上下文综合考量；
- 尽量不要混搭，保持体系一致性；
- 个人倾向 K8s + Spring Boot；

### 微服务参考架构图

![5][5]

![7][7]

## 技术中台到底讲什么？

阿里巴巴中台体系：

![6][6]

中台最早是由阿里巴巴提出来的，原来主要是业务和组织的概念。2015年阿里提出构建DT（Data Technology 数据处理技术，它是以服务大众、激发生产力为主的技术）时代，更灵活创新的大中台，小前台所谓的中台战略。

中台强调组织业务能力的沉淀、抽象、封装和重用，从而对各前台业务形成强力支撑，使得前台一线业务更敏捷，更快速适应瞬息万变的市场。

从具体架构上讲，阿里中台共分为四个抽象层次：

- 第一层：础设施即服务 IaaS（Infrastructure as a Service），主要负责计算、网络、存储、机房、数据中心这些基础设施；
- 第二层：平台即服务 PaaS（Platform as a Service），主要负责中间件、大数据基础服务、研发工具链等；
- 第三层：共享业务服务层，是阿里多年研发和运营沉淀下来的商业能力模块，这些能力被封装抽象成公共服务 API 供上游调用集成；
- 第四层：业务前台层，按照不同的业务线，比如：淘宝、天猫等划分，还可以根据不同的用户体验比如：PC、无线、第三方等，构建不同的用户接口层；

中台架构可以作为互联网组织和系统架构的一个参考模型，它的抽象层级比较高往往跟企业的战略关系比较密切。

## 微服务架构系列整理

以下是我在学习微服务架构相关资料的整理笔记，是目前比较主流的微服务架构开发技术栈：

- [微服务架构之API网关：Spring Cloud Gateway](https://xinlichao.cn/2020/02/14/back-end/java/spring-cloud-gateway/)
- [微服务架构之服务注册与发现：Spring Cloud Eureka](https://xinlichao.cn/2020/02/15/back-end/java/spring-cloud-eureka/)
- [微服务架构之客户端负载均衡：Spring Cloud Ribbon](https://xinlichao.cn/2020/02/16/back-end/java/spring-cloud-ribbon/)
- [微服务架构之声明式服务调用：Spring Cloud OpenFeign](https://xinlichao.cn/2020/02/18/back-end/java/spring-cloud-open-feign/)
- [微服务架构之服务容错：Spring Cloud Hystrix](https://xinlichao.cn/2020/02/19/back-end/java/spring-cloud-hystrix/)
- [微服务架构之API网关：Spring Cloud Zuul](https://xinlichao.cn/2020/02/22/back-end/java/spring-cloud-zuul/)
- [微服务架构之安全认证：Spring Cloud Security OAuth2](https://xinlichao.cn/2020/03/08/back-end/java/spring-cloud-oauth2/)
- [微服务架构之安全认证：JWT 令牌和 SSO](https://xinlichao.cn/2020/03/10/back-end/java/spring-cloud-jwt/)
- [微服务架构之熔断降级与限流：Spring Cloud Alibaba Sentinel](https://xinlichao.cn/2020/03/14/back-end/java/spring-cloud-alibaba-sentinel/)
- [微服务架构之配置中心：Apollo](https://xinlichao.cn/2020/03/15/back-end/java/apollo/)
- [微服务架构之调用链监控：Spring Cloud Sleuth & CAT & Skywalking](https://xinlichao.cn/2020/03/21/back-end/java/spring-cloud-sleuth/)
- [微服务架构之 Metrics 监控：Prometheus](https://xinlichao.cn/2020/03/22/back-end/java/prometheus/)
- [微服务架构之分布式缓存：Jetcache](https://xinlichao.cn/2020/03/25/back-end/java/jetcache/)
- [微服务架构之分布式事务：Spring Cloud Alibaba Seata](https://xinlichao.cn/2020/03/28/back-end/java/spring-cloud-alibaba-seata/)
- [Docker 安装 Jenkins](https://xinlichao.cn/2019/11/02/back-end/linux/docker-jenkins/)
- [Jenkins 部署前端 Vue 项目](https://xinlichao.cn/2019/11/03/back-end/linux/jenkins-vue/)
- [Jenkins 部署 Maven 聚合项目](https://xinlichao.cn/2019/11/04/back-end/linux/jenkins-maven-spring-boot/)
- [Docker 之 网络配置](https://xinlichao.cn/2019/11/12/back-end/docker/docker-network/)
- [Docker 三剑客之 Docker Compose](https://xinlichao.cn/2019/11/18/back-end/docker/docker-compose/)
- [Docker 三剑客之 Docker Machine](https://xinlichao.cn/2019/11/20/back-end/docker/docker-machine/)
- [Docker 三剑客之 Docker Swarm](https://xinlichao.cn/2019/11/21/back-end/docker/docker-swarm/)
- [使用 Docker 搭建 GitLab CE 实现 CI](https://xinlichao.cn/2019/11/27/back-end/docker/docker-gitlab/)
- [Kubernetes 基本概念](https://xinlichao.cn/2020/02/03/back-end/k8s/k8s-concepts/)
- [Kubernetes 基本命令](https://xinlichao.cn/2020/02/05/back-end/k8s/k8s-cmd/)
- [Kubernetes 网络](https://xinlichao.cn/2020/02/04/back-end/k8s/k8s-network/)

## Spring Cloud 微服务框架骨架模板

待抽离整理……

## 参考

- http://martinfowler.com/microservices/
- https://martinfowler.com/bliki/MonolithFirst.html
- https://martinfowler.com/bliki/MicroservicePremium.html
- https://spring.io/projects/spring-cloud/
- https://github.com/alibaba/spring-cloud-alibaba/
- https://github.com/Netflix/
- https://www.docker.com
- https://github.com/moby/moby/
- https://github.com/kubernetes/kubernetes/
- 《微服务架构实战》
- 《Spring Boot & Kubernetes 云原生微服务实践》
- 《从0开始学微服务》
- 《微服务设计》
- 《领域驱动设计》

[1]: /images/java/microservices-summary/1.jpg
[2]: /images/java/microservices-summary/2.jpg
[3]: /images/java/microservices-summary/3.jpg
[4]: /images/java/microservices-summary/4.jpg
[5]: /images/java/microservices-summary/5.jpg
[6]: /images/java/microservices-summary/6.jpg
[7]: /images/java/microservices-summary/7.jpg
