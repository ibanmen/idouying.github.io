---
title: 重学 Elastic Stack 之 Elasticsearch 深入了解(一)
date: 2021-02-06 15:00:00
categories: BigData
tags:
  - Elastic Stack
  - ES
---

深入了解 ES 高级搜索、相关性评分、搜索建议、自动补全等。

<!--more-->

## 基于词项和基于全文的搜索

### 基于 Term 的查询

- Term 的 重要性
  - **Term 是表达语意的最小单位**。搜索和利用统计语言模型进行自然语言处理都需要处理 Term
- 特点
  - Term Level Query：Term Query / Range Query / Exists Query / Prefix Query / Wildcard Query
  - 在 ES 中，Term 查询，对输入**不做分词**。会将输入作为一个整体，在倒排索引中查找准确的词项，并且使用相关度算分公式为每个包含该词项的文档进行**相关度算分** - 例如 “Apple Store”
  - 可以通过 Constant Score 将查询转换换成一个 Filtering，**避免算分，并利用缓存**，提交性能

**Demo** 

- 插入数据

```json
DELETE products
PUT products
{
  "settings": {
    "number_of_shards": 1
  }
}

POST /products/_bulk
{ "index": { "_id": 1 }}
{ "productID" : "XHDK-A-1293-#fJ3","desc":"iPhone" }
{ "index": { "_id": 2 }}
{ "productID" : "KDKE-B-9947-#kL5","desc":"iPad" }
{ "index": { "_id": 3 }}
{ "productID" : "JODL-X-1937-#pV7","desc":"MBP" }
```

- 查询

```json
// 多字段 Mapping 和 Term 查询
GET /products/_mapping

POST /products/_search
{
  "query": {
    "term": {
      "desc": {
        //"value": "iPhone"
        "value":"iphone"
      }
    }
  }
}

POST /products/_search
{
  "query": {
    "term": {
      "desc.keyword": {
        "value": "iPhone" //查不到数据，term查询
        //"value":"iphone" // 查到数据 term查询会做分词
      }
    }
  }
}

POST /products/_search
{
  "query": {
    "term": {
      "productID": {
        "value": "XHDK-A-1293-#fJ3"  // 无结果
        // "value": "xhdk" //有一条数据
        // "value": "xhdk-a-1293-#fj3"
      }
    }
  }
}

//如果对值进行查询
POST /products/_search
{
  //"explain": true,
  "query": {
    "term": {
      "productID.keyword": {
        "value": "XHDK-A-1293-#fJ3"
      }
    }
  }
}
```

### 复合查询 - Constant Score 转为 Filter

- 将 Query 转成 Filter，忽略 TF-IDF 计算，避免相关性算分的开销
- Filter 可以有效利用缓存

```json
POST /products/_search
{
  "explain": true,
  "query": {
    "constant_score": {
      "filter": {
        "term": {
          "productID.keyword": "XHDK-A-1293-#fJ3"
        }
      }
    }
  }
}
```

### 基于全文本的查询

- 基于全文本的查找
  - Match Query / Match Phrase Query / Query String Query
- 特点
  - 索引和搜索时会进行分词，查询字符串先传递到一个合适的分词器，然后生成一个供查询的词项列表
  - 查询时候，先**会对输入的查询进行分词**。然后每个词项逐个进行底层的查询，最终将结果进行合并。并未每个文档生成一个算分。 例如查 “Martix reloaded”, 会查到包括 Matrix 或者 reload 的所有结果。

#### Match Query Result

```json
POST movies/_search
{
  "query":{
    "match": {
      "title":{
        "query": "Matrix reloaded"
      }
    }
  }
}
```

#### Operator

```json
POST movies/_search
{
  "query":{
    "match": {
      "title":{
        "query": "Matrix reloaded",
        "operator": "AND"
      }
    }
  }
}
```

#### Minimun_should_match

```json
POST movies/_search
{
  "profile":true,
  "query":{
    "match": {
      "title":{
        "query": "Matrix reloaded",
        "minimum_should_match": 2 
      }
    }
  }
}
```

#### Match Phrase Query

```json
POST movies/_search
{
  "profile":true,
  "query":{
    "match_phrase": {
      "title":{
        "query": "Matrix reloaded",
        "slop": 1
      }
    }
  }
}
```

### Match Query 查询过程

- 基于全文本的查找
  - Match Query / Match Phrase Query / Query String Query
- 基于全文本的查询的特点
  - 索引和搜索时都会进行分词，查询字符串先传递到一个合适的分词器，然后生成一个供查询的词项列表
  - 查询会对每个词项逐个进行底层的查询，再将结果进行合并，并未每个文档生成一个算分

![1][1]

**小结**

- 基于词项的查找 vs 基于全文的查找
- 通过字段 Mapping 控制字段的分词
  - “Text” vs “Keyword”
- 通过参数控制查询的 Precision & Recall
- 复合查询
  - 即使是对 Keyword 进行 Term 查询，同样会进行算分
  - 可以将查询转为 Filtering，取消相关性算分的环节，以提高性能

## 结构化搜索

- 结构化搜索（Structured search） 是指对结构化数据的搜索
  - 日期，布尔类型和数字都是结构化
- 文本也可以是结构化的
  - 如彩色笔可以有离散的颜色集合：红（red）、绿（green）、蓝（blue）
  - 一个博客可能被标记了标签，例如，分布式（distributed）和搜索（search）
  - 电商网站上的商品都有 UPCs（通用产品码 Universal Product Codes）或其他的唯一标识，它们都遵从严格规定的、结构化的格式

### ES 中的机构化搜索

- 布尔、时间，日期和数字这类结构化数据：有精确的格式，我们可以对这些格式进行逻辑操作。包括比较数字或时间的范围，或判断两个值的大小
- 结构化的文本可以做到精确匹配或者部分匹配
  - Term 查询 / Prefix 前缀查询
- 结构化结构只有 “是” 或 “否” 两个值
  - 根据场景需要，可以决定结构化搜索是否需要打分

**Demo** 

```json
DELETE products
POST /products/_bulk
{"index":{"_id":1}}
{"price":10,"avaliable":true,"date":"2018-01-01","productID":"XHDK-A-1293-#fJ3"}
{"index":{"_id":2}}
{"price":20,"avaliable":true,"date":"2019-01-01","productID":"KDKE-B-9947-#kL5"}
{"index":{"_id":3}}
{"price":30,"avaliable":true,"productID":"JODL-X-1937-#pV7"}
{"index":{"_id":4}}
{"price":30,"avaliable":false,"productID":"QQPX-R-3956-#aD8"}

// 查看mapping
GET products/_mapping
{
  "products" : {
    "mappings" : {
      "properties" : {
        "avaliable" : {
          "type" : "boolean"
        },
        "date" : {
          "type" : "date"
        },
        "price" : {
          "type" : "long"
        },
        "productID" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }
  }
}
```

- 对布尔值 match 查询，有算分

```json
POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "term": {
      "avaliable": true
    }
  }
}
```

- 对布尔值，通过 constant score 转成 filtering，没有算分

```json
POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "constant_score": {
      "filter": {
        "term": {
          "avaliable": true
        }
      },
      "boost": 1.2
    }
  }
}
```

- 数字类型 Term

```json
POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "constant_score": {
      "filter": {
        "term": {
          "price": 30
        }
      },
      "boost": 1.2
    }
  }
}
```

- 数字类型 terms

```json
POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "constant_score": {
      "filter": {
        "terms": {
          "price": [
              "20",
              "30"
            ]
        }
      }
    }
  }
}
```

- 数字 Range 查询
  - gt 大于
  - lt 小于
  - gte 大于等于
  - lte 小于等于

```json
POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "constant_score": {
      "filter": {
        "range": {
          "price": {
             "gte": 20,
             "lte":30
          }
        }
      }
    }
  }
}
```

- 日期 range
  - Date Match Expressions
  - `2020-01-01 00:00:00 || +1M`

![2][2]

```json
POST products/_search
{
"query": {
  "constant_score": {
    "filter": {
      "range": {
        "date": {
           "gte": "now-1y"  //当前时间减1年
        }
      }
    }
  }
}
}
```

- exists 查询 - 非空查询

类似于SQL：`IS NOT NULL`

```json
POST products/_search
{
    "query" : {
        "constant_score" : {
            "filter" : {
                "exists": {
                    "field":"date"
                }
            }
        }
    }
}
```

类似于SQL：`IS NULL`

```json
POST products/_search
{
  "query": {
		"bool": {
			"must_not": [
				{
					"exists": {
						"field": "date"
					}
				}
			]
		}
  }
}
```

- 字符类型 terms

```json
POST products/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "terms": {
          "productID.keyword": [
            "QQPX-R-3956-#aD8",
            "JODL-X-1937-#pV7"
          ]
        }
      }
    }
  }
}
```

- 处理多值字段

```json
POST /movies/_bulk
{"index":{"_id":1}}
{"title":"Father of the Bridge Part II","year":1995,"genre":"Comedy"}
{"index":{"_id":2}}
{"title":"Dave","year":1993,"genre":["Comedy","Romance"]}
```

- 处理多值字段，term 查询是包含，而不是等于

```json
//返回2条数据
POST movies/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "term": {
          "genre.keyword": "Comedy"
        }
      }
    }
  }
}
```

- Match 跟 term 对比

```json
POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "term": {
      "date": "2019-01-01"
    }
  }
}

POST products/_search
{
  "profile": "true",
  "explain": true,
  "query": {
    "match": {
      "date": "2019-01-01"
    }
  }
}
```

**小结**

- 机构化数据 & 结构化搜索
  - 如果不需要算分，可以通过 Constant Score ，将查询转为 Filterng
- 范围查询 和 Date Match
- 使用 Exist 查询处理非空 NULL 值
- 精确值 & 多值字段的精确值查找
  - Term 查询是包含，不是完全相等。针对多值字段查询要尤其注意

**什么时候用 term 跟 match**

> 结构化数据的精确匹配，就使用 term 查询。日期属于结构化数据。match 主要用于文本的 full-text 查询

## 搜索的相关性算分

ES 对查询关键字和索引文档的相关度进行打分，得分高的就排在前边。

- 相关性 - Relevance
  - 搜索的相关性算分，描述了一个文档和查询语句匹配的程度。ES 会对每个匹配查询条件的结构进行算分_score
  - 打分的本质是排序 , 需要把最符合用户需求的文档排在前面。ES 5 之前，默认的相关性打分采用 TF-IDF，现在采用 BM25

| 词（Term） | 文档（Doc ID) |
| :---: | :---: |
| 区块链 | 1，2，3 |
| 的 | 2，3，4，5，6，7，8 |
| 应用 | 2，3，8，9，10 |

### 词频 TF

- Term Frequency∶ 检索词在一篇文档中出现的频率
  - 检索词出现的次数除以文档的总字数
- 度量一条查询和结果文档相关性的简单方法：简单将搜索中每一个 词的 TF 进行相加
  - $ TF(区块链) + TF(的) + TF(应用) $
- Stop Word
  - "的"在文档中出现了很多次，但是对贡献相关度几乎没有用处，不应该考虑他们的 TF

### 逆文档频率 IDF

- DF：检索词在所有文档中出现的频率

  - "区块链" 在相对比较少的文档中出现
  - "应用" 在相对比较多的文档中出现
  - "Stop Word" 在大量的文档中出现
- Inverse Document Frequency：$ 简单说 = log（全部文档数 / 检索词出现过的文档总数）$
- TF-IDF 本质上就是将 TF 求和变成了加权求和
- $ TF(区块链) * IDF(区块链) + TF(的) * IDF(的) + TF(应用) *  IDF(应用) $


|        | 出现的文档数 | 总文档数 | IDF  |
| :----: | :----: | :----: | :----: |
| 区块链 |    200万     | 10亿 | log(500) = 8.96 |
|   的   |     10亿     | 10亿 | log(1) = 0 |
|  应用  |     5亿      | 10亿 | log(2) = 1 |

> 这里 log 底数是 2

### TF-IDF 的概念

- TF-IDF 被公认为是信息检索领域最重要的发明
- 除了在信息检索，在文献分类和其他相关领域有着非常广泛的应用
- IDF 的概念，最早是剑桥大学的"斯巴克.琼斯"提出
  - 1972年 一 "关键词特殊性的统计解释和它在文献检索中的应用"
  - 但是没有从理论上解释 IDF应该是用 log（全部文档数 / 检索词出现过的文档总数），而不是其他函数。他也没有做进一步的研究
- 1970，1980年代萨尔顿和罗宾逊，进行了进一步的证明和研究，并用香农信息论做了证明
  - http://www.staff.city.ac.uk/~sbrp622/papers/foundations_bm25_review.pdf
- 现代搜索引擎，对 TF-IDF 进行了大量细微的优化

### Lucene 中的 TF-IDF 评分公式

![3][3]

- **score(q,d)** 是指查询输入Q和当前文档D的相关性得分；
- **coord(q,d)** 是协调因子，表示输入的Token被文档匹配到的比例；
- **queryNorm(q)** 是查询输入归一化因子，其作用是使最终的得分不至于太大，从而具有一定的可比性；
- **tf(t,d)** 表示输入的一个Token在文档中出现的频率，频率越高，得分越高；
- **idf(t) ** 表示输入的一个Token的频率级别，它具体的计算与当前文档无关，而是与索引中出现的频率相关，出现频率越低，说明这个词是个稀缺词，得分会越高；
- **boost(t)** 是查询时指定的权重；
- **norm(t,d)** 是指当前文档的Term数量的一个权重，文档越短，相关性越高。

### BM25

![4][4]

- 从 ES 5开始，默认算法改为 BM25；
- 和经典的 TF-ID F相比，当 TF无限增加时，BM 25 算分会趋于一个数值。

### 定制 Similarity

![5][5]

### 通过 Explain API 查看 TF-IDF

```json
PUT testscore/_bulk
{"index":{"_id":1}}
{"content":"we use Elasticsearch to power the search"}
{"index":{"_id":2}}
{"content":"we like elasticsearch"}
{"index":{"_id":3}}
{"content":"The scoring of documents is caculated by the scoring formula"}
{"index":{"_id":4}}
{"content":"you know, for search"}

//查询
POST /testscore/_search
{
  "explain": true,
  "query": {
    "match": {
     // "content":"you"
      "content": "elasticsearch"
      //"content":"the"
      //"content": "the elasticsearch"
    }
  }
}
```

### Boosting Relevance

- Boosting 是控制相关度的一种手段
  - 索引，字段或查询子条件
- 参数 boost 的含义
  - 当 boost > 1 时，打分的相关度相对性提高
  - 当 0 < boost < 1 时，打分的权重相对性降低
  - 当 boost < 0 时，贡献度负分

```json
POST testscore/_search
{
  "query": {
    "boosting" : {
      "positive" : {
        "term" : {
          "content" : "elasticsearch"
        }
      },
      "negative" : {
        "term" : {
          "content" : "like"
        }
      },
      "negative_boost" : 0.2
    }
  }
}
```

## Query & Filtering 与 多字符串多字段查询

![6][6]

- 高级搜索的功能：支持多项文本输入，针对多个字段进行搜索
- 搜索引擎一般也提供基于时间，价格等条件的过滤
- 在 ES 中，有 Query 和 Filter 两种 Context
  - Query Context：相关性算分
  - Filter Context：不需要算分（Yes or No）, 可以利用 Cache 获得更好的性能

### 条件组合

- 假设要搜索一本电影，包含了以下条件
  - 评论中包含了 Guitar ，用户打分高于 3 分，同时上映时间在 1993 到 2000 年之间
- 这个搜索包含了 3 段逻辑，针对不同的字段
  - 评论字段中要包含 Guitar 、用户评论大于 3、上映时间日期在给定范围内
- 同时包含这三个逻辑，并且有比较好的性能
  - 复合查询： bool Query

### bool 查询

- 一个 bool 查询，是一个或者多个查询子句的组合
  - 总共包含 4 种子句，其中 2 种会影响算分，2 种不影响算分
- 相关性并不只是全文本搜索的专利。也适合 yes | no 的子句，匹配的子句越多，相关性评分越高。如果多条查询子句被合并为一条复合查询语句，比如 bool 查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。

![7][7]

### bool 查询语句

- 子查询可以任意顺序出现
- 可以嵌套多个查询
- 如果你的 bool 查询中，没有 must 条件，should 中必须满足一条查询

```json
//插入数据
POST /products/_bulk
{"index":{"_id":1}}
{"price":10,"avaliable":true,"date":"2018-01-01","productID":"XHDK-A-1293-#fJ3"}
{"index":{"_id":2}}
{"price":20,"avaliable":true,"date":"2019-01-01","productID":"KDKE-B-9947-#kL5"}
{"index":{"_id":3}}
{"price":30,"avaliable":true,"productID":"JODL-X-1937-#pV7"}
{"index":{"_id":4}}
{"price":30,"avaliable":false,"productID":"QQPX-R-3956-#aD8"}
//查询
POST /products/_search
{
  "query": {
    "bool": {
      "must": {
        "term": {
          "price": "30"
        }
      },
      "filter": {
        "term": {
          "avaliable": "true"
        }
      },
      "must_not": {
        "range": {
          "price": {
            "lte": 10
          }
        }
      },
      "should": [
        {
          "term": {
            "productID.keyword": "JODL-X-1937-#pV7"
          }
        },
        {
          "term": {
            "productID.keyword": "XHDK-A-1293-#fJ3"
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}
```

**注意：ES中 同时使用 should 和 must 导致只有 must 生效**

> should 并不是 or 的关系

**解决1：**

使用多个must嵌套查询 将should组成的bool查询包含在其中一个must查询中

```json
GET _search
{
  "query": {
    "bool": {
      "must": [
        {
          "bool": {
            "should": [
              {
                "match_phrase": {
                  "title": "疫情期间"
                }
              },
              {
                "match_phrase": {
                  "content": "疫情期间"
                }
              }
            ]
          }
        },
        {
          "match": {
            "type": "1"
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "enabled": 0
          }
        }
      ]
    }
  },
  "highlight": {
    "pre_tags": [
      "<font color='red'>"
    ],
    "post_tags": [
      "</font>"
    ],
    "fields": {
      "title": {},
      "content": {}
    }
  }
}
```

**解决2：**

- minimum_should_match 设置为 1

### 如何解决结构化查询 - “包含而不是相等” 的问题

![8][8]

**增加 count 字段，使用 bool 查询**

- 从业务角度，按需改进 ES 数据模型

```json
POST /newmovies/_bulk
{"index":{"_id":1}}
{"title":"Father of the Bridge Part II","year":1995,"genre":"Comedy","genre_count":1}
{"index":{"_id":2}}
{"title":"Dave","year":1993,"genre":["Comedy","Romance"],"genre_count":2}

// Query Context - 影响算分
// must 有算分
POST /newmovies/_search
{
"query": {
  "bool": {
    "must": [
      {"term": {"genre.keyword": {"value": "Comedy"}}},
      {"term": {"genre_count": {"value": 1}}}
    ]
  }
}
}
// Filter Context - 不影响算分
// Filter。不参与算分，结果的score是0
POST /newmovies/_search
{
"query": {
  "bool": {
    "filter": [
      {"term": {"genre.keyword": {"value": "Comedy"}}},
      {"term": {"genre_count": {"value": 1}}}
      ]
  }
}
}
```

### bool 嵌套

![9][9]

### 查询语句的结构，会对相关度算分产生影响

- 同一层级下的竞争字段，具有相同的权重
- 通过嵌套 bool 查询，可以改变对算分的影响

![10][10]

### 控制字段的 Boosting

![11][11]

### Not Quite Not

![12][12]

### Boosting Query

![13][13]

**小结**

- Query Context vs Filter Context
- Bool Query - 更多的条件组合
- 查询结构与相关性算分
- 如何控制查询的精确度
  - Boosting & Boosting Query

## 单字符串多字段查询：Dis Max Query

### 单字符串查询

- Google 只提供一个输入框，查询相关的多个字段
- 支持按照价格，时间等进行过虑

**单字符串查询的实例**

- 博客标题
  - 文档1中出现"Brown"
- 博客内容
  - 文档1中出现了"Brown"
  - "Brown fox"在文档 2中全部出现，并且保持和查询一致的顺序（目测相关性最高）

```json
PUT /blogs/_doc/1
{
  "title": "Quick brown rabbits",
  "body": "Brown rabbits are commonly seen."
}
PUT /blogs/_doc/2
{
  "title": "Keeping pets healthy",
  "body": "My quick brown fox eats rabbits on a regular basis."
}
//查询语句
POST /blogs/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "title": "Brown fox"
          }
        },
        {
          "match": {
            "body": "Brown fox"
          }
        }
      ]
    }
  }
}
```

#### 算分过程

- 查询 should 语句中的两个查询
- 加和两个查询的评分
- 乘以匹配语句的总数
- 除以所有语句的总数

#### 结果分析

```json
"hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 0.90425634,
    "hits" : [
      {
        "_index" : "blogs",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.90425634, // 因为2个字段都有brown
        "_source" : {
          "title" : "Quick brown rabbits",
          "body" : "Brown rabbits are commonly seen."
        }
      },
      {
        "_index" : "blogs",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : 0.77041256,
        "_source" : {
          "title" : "Keeping pets healthy",
          "body" : "My quick brown fox eats rabbits on a regular basis."
        }
      }
    ]
  }
```

![14][14] ![15][15]

### Disjunction Max Query 查询

- 上列中，title 和 body 相互竞争
  - 不应该将分数简单叠加，而是应该找个单个最佳匹配的字段的评分
- Disjunction Max Query
  - 将任何与任一查询匹配的文档作为结果返回。采用字段上最匹配的评分返回

![16][16]

### 最佳字段查询调优

- 有一些情况下，同时匹配 title 和 body 字段的文档比只与一个字段匹配的文档的相关度更高
- 但 disjunction max query 查询指挥简单的使用单个最佳匹配语句的评分_scoce 作为整体评分，怎么办？

### 通过 Tie Breaker 参数调整

- 获得最佳匹配语句的评分 _score
- 将其他匹配语句的评分 与 tie_breaker 相乘
- 对以上评分求和并规范化
  - Tie Breanker 是一个介于 0-1 之间的浮点数。0 代表使用最佳匹配；1 代表所有语句同等重要。

```json
POST blogs/_search
{
"query": {
  "dis_max": {
      "queries": [
          { "match": { "title": "Quick pets" }},
          { "match": { "body":  "Quick pets" }}
      ],
      "tie_breaker": 0.2
  }
}
}
```

## 单字符串多字段查询: Multi Match

- 最佳字段（Best Fields）
  - 当字段之间相互竞争，又相互关联。例如 title 和 body 这样的字段，评分来自最匹配字段
- 多数字段（Most Fields）
  - 处理英文内容时：一种常见的手段是，在主字段（English Analyzer），抽取词干，加入同义词，以匹配更多的文档。相同的文本，加入子字段（Standard Analyzer），以提供更加精确的匹配。其他字段作为匹配文档提高性相关度的信号。匹配字段越多越好
- 混合字段（Cross Field）
  - 对于某些实体，例如人名，地址，图书信息。需要在多个字段中确定信息，单个字段只能作为整体的一部分。希望在任何这些列出的字段中尽可能找出多的词

### Multi Match Query

- Best Fields 是默认类型，可不指定
- Minimum should match 等参数可以传递到生成的 query 中

```json
POST blogs/_search
{
  "query": {
    "multi_match": {
      "type": "best_fields",
      "query": "Quick pets",
      "fields": ["title","body"],
      "tie_breaker": 0.2,
      "minimum_should_match": "20%"
    }
  }
}
```

**查询案例**

- 英文分词器，导致精确度降低，时态信息丢失

```json
PUT /titles
{
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "english"
      }
    }
  }
}

POST titles/_bulk
{"index":{"_id":1}}
{"title":"My dog barks"}
{"index":{"_id":2}}
{"title":"I see a lot of barking dogs on the road "}

GET titles/_search
{
  "query": {
    "match": {
      "title": "barking dogs"
    }
  }
}
//结果 因为是english 分词 ，且短 则 id 排第一个
"hits" : [
      {
        "_index" : "titles",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.24399278,
        "_source" : {
          "title" : "My dog barks"
        }
      },
      {
        "_index" : "titles",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : 0.1854345,
        "_source" : {
          "title" : "I see a lot of barking dogs on the road "
        }
      }
    ]
```

**重新设置 mapping**

```json
DELETE titles
PUT /titles
{
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "english",
        "fields": {
          "std":{
            "type":"text",
            "analyzer":"standard"
          }
        }
      }
    }
  }
}
POST titles/_bulk
{"index":{"_id":1}}
{"title":"My dog barks"}
{"index":{"_id":2}}
{"title":"I see a lot of barking dogs on the road "}
//multi_match 查询
GET titles/_search
{
  "query": {
    "multi_match": {
      "query": "barking dogs",
      "type": "most_fields", //默认是best_fields
      "fields": ["title","title.std"]//累计叠加
    }
  }
}
//返回
"hits" : [
      {
        "_index" : "titles",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : 1.4569323,
        "_source" : {
          "title" : "I see a lot of barking dogs on the road "
        }
      },
      {
        "_index" : "titles",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.42221838,
        "_source" : {
          "title" : "My dog barks"
        }
      }
    ]
```

### 使用多字段匹配解决

- 用广度匹配字段 title 包括尽可能多的文档 - 以提高召回率 ，同时又使用字段 title.std 作为信息将相关度更高的文档结至于文档顶部
- 每个字段对于最终评分的贡献可以通过自定义值 boost 来控制。比如，使 title 字段更为重要，这样同时也降低了其他信号字段的作用

```json
GET titles/_search
{
  "query": {
    "multi_match": {
      "query": "barking dogs",
      "type": "most_fields", 
      "fields": ["title^10","title.std"]
    }
  }
}
```

### 跨字段搜索

- most_fields 无法使用 opeartor
  - 可以用 copy_to 解决，但是需要额外的储存空间
- cross_fields 可以支持 operator
  - 与 copy_to 相比，其中一个优势就是可以在搜索时为某个字段提升权重

```json
PUT address/_doc/1
{
  "street":"5 Poland Street",
  "city" : "Lodon",
  "country":"United Kingdom",
  "postcode" : "W1V 3DG"
}

POST address/_search
{
  "query":{
    "multi_match": {
      "query": "Poland Street W1V",
      "type": "cross_fields",  //most_fields查询为空
      "operator": "and", 
      "fields": ["street","city","country","postcode"]
    }
  }
}
"hits" : [
      {
        "_index" : "address",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.8630463,
        "_source" : {
          "street" : "5 Poland Street",
          "city" : "Lodon",
          "country" : "United Kingdom",
          "postcode" : "W1V 3DG"
        }
      }
    ]
```

## 多语言及中文分词与检索

### 自然语言与查询 Recall

- 当处理人类自然语言时，有些情况，尽管搜索和原文不完全匹配，但是希望搜到一些内容
  - Quick brown fox 和 fast brown fox / Jumping fox 和 Jumped foxes
- 一些可采取的优化
  - 归一化词元：清除变音符号，如 rÔle 的的时候 也会匹配 role
  - 抽取词根：清除单复数和时态的差异
  - 包含同义词
  - 拼写错误：拼写错误，或者同音异形词

### 混合多语言的挑战

- 一些具体的多语言场景
  - 不同的索引使用不同的语言 / 同一索引中，不同的字段使用不同的语言 / 一个文档的一个字段内混合不同的语言
- 混合语言存在的一些挑战
  - 词干提取：以色列文档，包含了希伯来语，阿拉伯语，俄语和英文
  - 不争取的文档频率 - 英文为主的文章中，德文算分高（稀有）
  - 需要判断用户搜索时使用的语言，语言识别（Compact Language Detecor）
    - 例如，根据语言查询不同的索引

### 分词的挑战

- 英文分词：You’re 分成一个还是多个？Half-baked
- 中文分词
  - 分词的标椎：哈工大标椎中，姓和名分开。HanLP 是在一起的。具体情况需制定不同的标椎
  - 歧义（组合型歧义，交际型歧义，真歧义）
    - 中华人民共和国 / 美国会通过对台收武器法案 / 上海仁和服装厂

### 中文分词方法的演变 - 字典法

- 查字典 - 最容易想到的分词方法（北京航空大学的梁南元教授提出）
  - 一个句子从左到到右扫描一遍。遇到有点词就标识出来。找到复合词，就找最长的
  - 不认识的字符串就分割成单字词
- 最小词数的分词理论 - 哈工大王晓龙博士吧查字典的方法理论化
  - 一句话应该分词数量最少的词串
  - 遇到二义性的分割，无能为力（例如：“发展中国家”/“上海大学城书店”）
  - 用各种文化规则来解决二义性，都并不成功

### 中文分词方法的演变 - 基于统计法的机器学习算法

- 统计语言模型 - 1990 年前后 ，清华大学电子工程系郭进博士
  - 解决了二义性问题，将中文分词的错误率降低了一个数据级。概率问题，动态规划 + 利用维特比算法快速找到最佳分词
- 基于统计的机器学习算法
  - 这类目前常用的算法是 HMM、CRF、SVM、深度学习算法等算法。比如 Hanlp 分词工具是基于 CRF 算法为例，基本思路是对汉字进行标注训练，不仅考虑了词语出现的频率，还考虑上下文，具有较好的学习能力，因此其对歧义词和未登录词的识别都具有良好的下效果
  - 随着深度学习的兴起，也出现了基于神经网路的分词器，有人尝试使用双向 LSTM + CRF 实现分词器，其本质上是序列标注，据报道其分词器字符准确率可高达 97.5%

### 中文分词器现状

- 中文分词器以统计语言模型为基础，经过几十年的发展，今天基本已经可以看做是一个已经解决的问题
- 不同分词器的好坏，主要的差别在于数据的使用和工程使用的精度
- 常见的分词器都是使用机器学期算法和词典相结合，一方面能够提高分词准确率，另一方面能够改善领域适应性

### 一些分词工具

- Elasticsearch IK分词插件 https://github.com/medcl/elasticsearch-analysis-ik/releases
- Elasticsearch HanLP 分词插件 https://github.com/KennFalcon/elasticsearch-analysis-hanlp
- 中科院计算所NLPIR http://ictclas.nlpir.org/nlpir/
- ansj分词器 https://github.com/NLPchina/ansj_seg
- 哈工大的LTP https://github.com/HIT-SCIR/ltp
- 清华大学THULAC https://github.com/thunlp/THULAC
- 斯坦福分词器 https://nlp.stanford.edu/software/segmenter.shtml
- Hanlp分词器 https://github.com/hankcs/HanLP
- 结巴分词 https://github.com/yanyiwu/cppjieba
- KCWS分词器(字嵌入+Bi-LSTM+CRF) https://github.com/koth/kcws
- ZPar https://github.com/frcchang/zpar/releases
- IKAnalyzer https://github.com/wks/ik-analyzer

### 中文分词 DEMO

- 使用不同分词器测试效果
- 索引时，尽量切分的短，查询的时候，尽量用长的词
- 拼音分词器

```bash
#安装插件

# IK Analysis - 支持字典热更新
bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.1.0/elasticsearch-analysis-ik-7.1.0.zip

# 拼音
bin/elasticsearch install https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v7.1.0/elasticsearch-analysis-pinyin-7.1.0.zip

# HanLP - 支持加载远程字典
bin/elasticsearch install https://github.com/KennFalcon/elasticsearch-analysis-hanlp/releases/download/v7.1.0/elasticsearch-analysis-hanlp-7.1.0.zip

```

```json
// ik_max_word
// ik_smart
// hanlp: hanlp默认分词
// hanlp_standard: 标准分词
// hanlp_index: 索引分词
// hanlp_nlp: NLP分词
// hanlp_n_short: N-最短路分词
// hanlp_dijkstra: 最短路分词
// hanlp_crf: CRF分词（在hanlp 1.6.6已开始废弃）
// hanlp_speed: 极速词典分词

POST _analyze
{
  "analyzer": "hanlp_standard",
  "text": ["剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜"]
}     

// Pinyin
PUT /artists/
{
    "settings" : {
        "analysis" : {
            "analyzer" : {
                "user_name_analyzer" : {
                    "tokenizer" : "whitespace",
                    "filter" : "pinyin_first_letter_and_full_pinyin_filter"
                }
            },
            "filter" : {
                "pinyin_first_letter_and_full_pinyin_filter" : {
                    "type" : "pinyin",
                    "keep_first_letter" : true,
                    "keep_full_pinyin" : false,
                    "keep_none_chinese" : true,
                    "keep_original" : false,
                    "limit_first_letter_length" : 16,
                    "lowercase" : true,
                    "trim_whitespace" : true,
                    "keep_none_chinese_in_first_letter" : true
                }
            }
        }
    }
}

GET /artists/_analyze
{
  "text": ["刘德华 张学友 郭富城 黎明 四大天王"],
  "analyzer": "user_name_analyzer"
}

curl -XPOST http://localhost:9200/index/_mapping -H 'Content-Type:application/json' -d {
  "properties": {
    "content": {
      "type": "text",
      "analyzer": "ik_max_word",
      "search_analyzer" : "ik_smart"
    }
  }
}
```

## 测试相关性一理解原理 ＋ 多分析 ＋ 多调整测试

- 技术分为道和术两种
  - 道 一 原理和原则
  - 术 一 具体的做法，具体的解法
- 关于搜索，为了有一个好的搜索结果。除了真正理解背后的原理，更需要多加实践与分析
  - 单纯追求"术"，会一直很辛苦。只有掌握了本质和精髓之"道"，做事才能游刃有余
  - 要做好搜索，除了理解原理，也需要坚持去分析一些不好的搜索结果。只有通过一定时间的积累，
才能真正有所感觉
  - 总希望一个模型，一个算法，就能毕其功于一役，是不现实的

### 监控并且理解用户行为

- 不要过度调试相关度
- 而要监控搜索结果，监控用户点击最顶端结果的频次
- 将搜索结果提高到极高水平，唯一途径就是
  - 需要具有度量用户行为的强大能力
  - 可以在后台实现统计数据，比如，用户的查询和结果，有多少被点击了
  - 哪些搜索，没有返回结果

## 使用 Search Template 和 Index Alias

### Search Template - 解耦程序 & 搜索 DSL

- Elasticsearch 的查询语句
  - 对相关性算分 / 查询性能都至关重要
- 在开发初期，虽然可以明确查询参数，但是往往还不能最终定义查询的 DSL 的具体结构
  - 通过 Search Template 定义一个 Contract
- 各司其职，解耦
  - 开发人员 / 搜索工程师 / 性能工程师
  
### 使用 Search Template 进行查询

```json
DELETE _scripts/tmdb
// 定义模板
POST _scripts/tmdb
{
  "script": {
    "lang": "mustache",
    "source": {
      "_source": [
        "title","overview"
      ],
      "size": 20,
      "query": {
        "multi_match": {
          "query": "{{q}}",
          "fields": ["title","overview"]
        }
      }
    }
  }
}

GET _scripts/tmdb

POST tmdb/_search/template
{
    "id":"tmdb",
    "params": {
        "q": "basketball with cartoon aliens"
    }
}
```

### 使用 Index Alias 实现零停机运维

```json
PUT movies-2019/_doc/1
{
  "name":"the matrix",
  "rating":5
}

PUT movies-2019/_doc/2
{
  "name":"Speed",
  "rating":3
}

POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "movies-2019",
        "alias": "movies-latest" // 为索引创建个别名
      }
    }
  ]
}

//通过别名读写数据
POST movies-latest/_search
{
  "query": {
    "match_all": {}
  }
}
```

### 使用 Alias 创建不同查询的视图

```json
POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "movies-2019",
        "alias": "movies-lastest-highrate",
        "filter": {
          "range": {
            "rating": {
              "gte": 4
            }
          }
        }
      }
    }
  ]
}

POST movies-lastest-highrate/_search
{
  "query": {
    "match_all": {}
  }
}
```

## 综合排序 Function Score Query 优化算分

### 算分与排序

- ES 默认会以文档的相关度算分进行排序
- 可以通过制定一个或者多个字段进行排序
- 使用相关性算分（score）排序，不能满足某些特定条件
  - 无法针对相关度，对排序实现更多的控制

### Function Score Query

- Function Score Query
  - 可以在查询结束后，对每一个匹配的文档进行一系列的重新算分，根据新生成的分数进行排序
- 提供了几种默认的计算分值的函数
  - Weight：为每一个文档设置一个简单而不被规范化的权重
  - Field Value Factor：使用该数值来修改_score，例如将 “热度” 和 “点赞数” 作为算分的参考因素
  - Random Score：为每一个用户使用一个不同的，随机算分结果
  - 衰减函数∶ 以某个字段的值为标准，距离某个值越近，得分越高
  - Script Score∶ 自定义脚本完全控制所需逻辑

### 按受欢迎度提升权重

- 希望能够将点赞多的 blog，放在搜索列表相对靠前的位置。同事搜索的评分，还是要作为排序的主要依据
- 新的算分 = 老的算分 * 投票数
  - 投票数为 0
  - 投票数很大时

```json
DELETE blogs
PUT /blogs/_doc/1
{
  "title":   "About popularity",
  "content": "In this post we will talk about...",
  "votes":   0
}

PUT /blogs/_doc/2
{
  "title":   "About popularity",
  "content": "In this post we will talk about...",
  "votes":   100
}

PUT /blogs/_doc/3
{
  "title":   "About popularity",
  "content": "In this post we will talk about...",
  "votes":   1000000
}


POST /blogs/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field": "votes"
      }
    }
  }
}
```

### 使用 Modifier 平滑曲线

- 新的算分 = 老的算分 * log（1 + 投票数）

![17][17]

```json
POST /blogs/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field": "votes",
        "modifier": "log1p"
      }
    }
  }
}
```

### 引入 Factor

- 新的算分 = 老的算分 * log（1 + factor * 投票数）

![18][18]

```json
POST /blogs/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field": "votes",
        "modifier": "log1p" ,
        "factor": 0.1
      }
    }
  }
}
```

### Boost Mode 和 Max Boost

- Boost Mode
  - Multiply：算分和函数值的乘积
  - Sum：算分和函数值的和
  - Min/Max：算分与函数去 最小 / 最大值
  - Replace：使用函数取代算分
- Max Boost 可以将算分控制在一个最大值

```json
POST /blogs/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field": "votes",
        "modifier": "log1p" ,
        "factor": 0.1
      },
      "boost_mode": "sum",
      "max_boost": 3
    }
  }
}
```

### 一致性随机函数

- 使用场景：网址的广告需要提高展示率
- 具体需求：让每个用户看到不同的随机排名，但是也希望同一个用户访问时，结果的相对顺序，保持一致（Consistently Random）

```json
POST /blogs/_search
{
  "query": {
    "function_score": {
      "random_score": {
        "seed": 911119
      }
    }
  }
}
```

## Term & Phrase Suggester

### 什么是搜索建议

- 现代的搜索引擎，一般都会提供 Suggest as you type 的功能
- 帮助用户在输入搜索的过程中，进行自动补全或者纠错。通过协助用户输入更加精准的关键词，提高后续搜索阶段文档匹配的程度
- 在 google 上搜索，一开始会自动补全。当输入到一定长度，如因为单词拼写错误无法补全，就会开始提示相似的词或者句子

### Elasticsearch Suggester API

- 搜索引擎中类似的功能，在 ES 中通过 Sugester API 实现的
- 原理：将输入的文档分解为 Token，然后在索引的字段里查找相似的 Term 并返回
- 根据不同的使用场景，ES 设计了 4 种类别的 Suggesters
  - Term & Phrase Suggester
  - Complete & Context Suggester

### Term Suggester

- Suggester 就是一种特殊类型的搜索。“text” 里是调用时候提供的文本，通常来自用户界面上用户输入的内容
- 用户输入的 “lucen” 是一个错误的拼写
- 会到 指定的字段 “body” 上搜索，当无法搜索到结果时（missing），返回建议的词

### Term Suggester - Missing Mode

- 搜索 “lucen rock”：
  - 每个建议都包含了一个算分，相似性是通过 Levenshtein Edit Distance 的算法实现的。核心思想就是一个词改动多少字段就可以和另外一个词一致。提供了很多可选参数来控制相似性的模糊程度。
- 几种 Suggestion Mode
  - Missing - 如索引中已存在，就不提供建议
  - Popular - 推荐出现频率更加高的词
  - Always - 无论是否存在，都提供建议

```json
//插入数据
POST article/_bulk
{"index":{}}
{"body":"lucene is very cool"}
{"index":{}}
{"body":"Elasticsearch builds on top of lucene"}
{"index":{}}
{"body":"Elasticsearch rocks"}
{"index":{}}
{"body":"elastic is the company behind ELK stack"}
{"index":{}}
{"body":"Elk stack rocks"}
{"index":{}}
{"body":"elasticsearch is rock solid"}
//suggest
POST article/_search
{
  "size": 1,
  "query": {
    "match": {
      "body": "lucen rock"
    }
  },
  "suggest": {
    "term-suggestion": {
      "text": "lucen rock",
      "term": {
        "suggest_mode": "missing", // popular  always
        "field": "body"
      }
    }
  }
}
//返回结果
"suggest" : {
    "term-suggestion" : [
      {
        "text" : "lucen",
        "offset" : 0,
        "length" : 5,
        "options" : [
          {
            "text" : "lucene",//推荐了
            "score" : 0.8,
            "freq" : 2
          }
        ]
      },
      {
        "text" : "rock",//没有推荐
        "offset" : 6,
        "length" : 4,
        "options" : [ ]
      }
    ]
  }
```

- 默认使用 standard 分词器
  - 大写转小写
  - rocks 和 rock 是两个词

### Term Suggester - Popuar Mode

```json
POST article/_search
{
  "suggest": {
    "term-suggestion": {
      "text": "lucen rock",
      "term": {
        "suggest_mode": "popular",
        "field": "body"
      }
    }
  }
}
//返回
"suggest" : {
    "term-suggestion" : [
      {
        "text" : "lucen",
        "offset" : 0,
        "length" : 5,
        "options" : [
          {
            "text" : "lucene",
            "score" : 0.8,
            "freq" : 2
          }
        ]
      },
      {
        "text" : "rock",
        "offset" : 6,
        "length" : 4,
        "options" : [
          {
            "text" : "rocks",
            "score" : 0.75,
            "freq" : 2
          }
        ]
      }
    ]
  }
```

### Sorting by Frequency & PrefixLength

- 默认按照 score 排序，也可以按照 "frequency"
- 默认首字母不一致就不会匹配推荐，但是如果将 prefix_length 设置为 0，就会为 hock 建议 rock

```json
POST /articles/_search
{

  "suggest": {
    "term-suggestion": {
      "text": "lucen hocks",
      "term": {
        "suggest_mode": "always",
        "field": "body",
        "prefix_length":0,
        "sort": "frequency"
      }
    }
  }
}
```

### Phrase Suggester

- Phrase Suggesetr 上增加了一些额外的逻辑
一些参数
  - Suggeset Mode ： missing,popular ,always
  - Max Errors: 最多可以拼错的 Terms 数
  - Condfidence ： 限制返回结果数，默认为 1

```json
POST /articles/_search
{
  "suggest": {
    "my-suggestion": {
      "text": "lucne and elasticsear rock hello world ",
      "phrase": {
        "field": "body",
        "max_errors":2,
        "confidence":0,
        "direct_generator":[{
          "field":"body",
          "suggest_mode":"always"
        }],
        "highlight": {
          "pre_tag": "<em>",
          "post_tag": "</em>"
        }
      }
    }
  }
}
```

## 自动补全与基于上下文的提示

### The Completion Suggester

- Completion Suggester 提供了 “自动完成”（Auto Complete）的功能。用户每输入一个字符，就需要即时发送一个查询请求到后端查询匹配项
- 对性能要求比较苛刻。ES 采用了不同的数据结构，并非通过倒排索引来完成。而是将 Analyze 的数据编码成 FST 和索引一起存放。FST 会被 ES 整个加载进内存，速度很快
- FST 只能用于前缀查找

### 使用 Completion Suggester 一些步骤

- 定义 Mapping，使用 “completion” type
- 索引数据
- 运行 “suggest” 查询，得到搜索建议

```json
//定义mapping
PUT articles
{
  "mappings": {
    "properties": {
      "title_completion": {
        "type": "completion"
      }
    }
  }
}
//写入数据
POST articles/_bulk
{"index":{}}
{"title_completion":"lucene is very cool"}
{"index":{}}
{"title_completion":"Elasticsearch builds on top of lucene"}
{"index":{}}
{"title_completion":"Elasticsearch rocks"}
{"index":{}}
{"title_completion":"elastic is the company behind ELK stack"}
{"index":{}}
{"title_completion":"Elk stack rocks"}
{"index":{}}
//查询
POST articles/_search?pretty
{
  "size": 0,
  "suggest": {
    "article-suggest": {
      "prefix": "e", //查询字段 
      "completion": {
        "field": "title_completion"
      }
    }
  }
}
```

### 什么是 Context Suggester

- Completion Suggester 的扩展
- 可以在搜索中加入耕读偶读上下文信息，例如，输入 “star”
  - 咖啡相关：starbucks
  - 电影相关：star wars

### 实现 Context Suggester

- 可以定义两种类型的 Context
  - Category - 任意的字符串
  - Geo - 地理信息位置
- 实现 Context Suggester
  - 定制一个 Mapping
  - 索引数据，并且为每个文档加入 Conetxt 信息
  - 结合 Context 进行 Suggestion 查询

```json
DELETE comments
PUT comments

// 添加 contexts type 和 name
PUT comments/_mapping
{
  "properties":{
    "comment_autocomplete":{
      "type":"completion",
      "contexts":[{
       "type":"category",
       "name":"comment_category"
      }]
    }
  }
}
// 索引数据 设置不同的 category
POST comments/_doc
{
  "comment": "I love the star war movies",
  "comment_autocomplete": {
    "input": ["star wars"],
    "contexts": {
      "comment_category": "movies"
    }
  }
}
POST comments/_doc
{
  "comment":"Where can I find a Starbucks",
  "comment_autocomplete":{
    "input":["starbucks"],
    "contexts":{
      "comment_category":"coffee"
    }
  }
}
POST comments/_search
{
  "suggest": {
    "MY_SUGGESTION": {
      "prefix": "sta",
      "completion":{
        "field":"comment_autocomplete",
        "contexts":{
         "comment_category":"movies" 
        //  "comment_category":"coffee"  
        }
      }
    }
  }
}
```

### 精确度和召回率

- 精准度
  - Completion > Phrase > Term
- 召回率
  - Term > Phrase > Completion
- 性能
  - Completion > Phrase > Term

## 跨集群搜索

### 水平扩展的痛点

- 单集群 - 当水平扩展时，节点数不能无限增加
  - 当集群的 meta 信息（节点，索引，集群状态）过多，会导致更新压力变大，单个 Active Master 会成为性能瓶颈，导致整个集群无法正常工作
- 早起版本，通过 Tribe Node 可以实现多集群访问的需求，但是还存在一定的问题
  - Tribe Node 会以 Client Node 的方式加入集群。集群中 Master 节点的任务变更需要 Tribe Node 的回应才能继续
  - Tribe Node 不保存 Cluster State 信息，一旦重启，初始化很慢
  - 当多个集群存在索引重名的情况下，只能设置一种 Perfer 规则

### 跨集群搜索 - Cross Cluster Search

- 早期 Tribe Node 的方案存在一定的问题，现已被 Deprecated
- ES 5.3 引入跨集群搜索的功能（Cross Cluster Search），推荐使用
  - 允许任何节点扮演 federated 节点，以轻量的方式，将搜索请求进行代理
  - 不需要以 Client Node 的形式加入其它集群

```bash
# 启动3个集群
bin/elasticsearch -E node.name=cluster0node -E cluster.name=cluster0 -E path.data=cluster0_data -E discovery.type=single-node -E http.port=9200 -E transport.port=9300
bin/elasticsearch -E node.name=cluster1node -E cluster.name=cluster1 -E path.data=cluster1_data -E discovery.type=single-node -E http.port=9201 -E transport.port=9301
bin/elasticsearch -E node.name=cluster2node -E cluster.name=cluster2 -E path.data=cluster2_data -E discovery.type=single-node -E http.port=9202 -E transport.port=9302
```

```json
//在每个集群上设置动态的设置
PUT _cluster/settings
{
  "persistent": {
    "cluster": {
      "remote": {
        "cluster0": {
          "seeds": [
            "127.0.0.1:9300"
          ],
          "transport.ping_schedule": "30s"
        },
        "cluster1": {
          "seeds": [
            "127.0.0.1:9301"
          ],
          "transport.compress": true,
          "skip_unavailable": true
        },
        "cluster2": {
          "seeds": [
            "127.0.0.1:9302"
          ]
        }
      }
    }
  }
}
```

```bash
# cURL
curl -XPUT "http://localhost:9200/_cluster/settings" -H 'Content-Type: application/json' -d'
{"persistent":{"cluster":{"remote":{"cluster0":{"seeds":["127.0.0.1:9300"],"transport.ping_schedule":"30s"},"cluster1":{"seeds":["127.0.0.1:9301"],"transport.compress":true,"skip_unavailable":true},"cluster2":{"seeds":["127.0.0.1:9302"]}}}}}'

curl -XPUT "http://localhost:9201/_cluster/settings" -H 'Content-Type: application/json' -d'
{"persistent":{"cluster":{"remote":{"cluster0":{"seeds":["127.0.0.1:9300"],"transport.ping_schedule":"30s"},"cluster1":{"seeds":["127.0.0.1:9301"],"transport.compress":true,"skip_unavailable":true},"cluster2":{"seeds":["127.0.0.1:9302"]}}}}}'

curl -XPUT "http://localhost:9202/_cluster/settings" -H 'Content-Type: application/json' -d'
{"persistent":{"cluster":{"remote":{"cluster0":{"seeds":["127.0.0.1:9300"],"transport.ping_schedule":"30s"},"cluster1":{"seeds":["127.0.0.1:9301"],"transport.compress":true,"skip_unavailable":true},"cluster2":{"seeds":["127.0.0.1:9302"]}}}}}'


# 创建测试数据
curl -XPOST "http://localhost:9200/users/_doc" -H 'Content-Type: application/json' -d'
{"name":"user1","age":10}'

curl -XPOST "http://localhost:9201/users/_doc" -H 'Content-Type: application/json' -d'
{"name":"user2","age":20}'

curl -XPOST "http://localhost:9202/users/_doc" -H 'Content-Type: application/json' -d'
{"name":"user3","age":30}'

```

```json
// 查询
GET /users,cluster1:users,cluster2:users/_search
{
  "query": {
    "range": {
      "age": {
        "gte": 20,
        "lte": 40
      }
    }
  }
}
```

## 参考

- https://www.elastic.co/guide/en/elasticsearch/reference/7.1/term-level-queries.html
- https://www.elastic.co/guide/en/elasticsearch/reference/7.1/full-text-queries.html
- https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html
- https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html
- https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-boosting-query.html
- https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-dis-max-query.html
- https://www.elastic.co/guide/en/elasticsearch/reference/7.1/search-request-highlighting.html
- https://www.elastic.co/guide/en/elasticsearch/reference/7.12/highlighting.html
- [分词算法综述](https://zhuanlan.zhihu.com/p/50444885)
- https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-function-score-query.html
- 《Elasticsearch核心技术与实战》
- [在Kibana中使用Cross data search](https://kelonsoftware.com/cross-cluster-search-kibana/)
- [实战 | Elasticsearch自定义评分的N种方法](https://blog.csdn.net/laoyang360/article/details/104809787)

[1]: /images/big-data/es-05/1.jpg
[2]: /images/big-data/es-05/2.jpg
[3]: /images/big-data/es-05/3.jpg
[4]: /images/big-data/es-05/4.jpg
[5]: /images/big-data/es-05/5.jpg
[6]: /images/big-data/es-05/6.jpg
[7]: /images/big-data/es-05/7.jpg
[8]: /images/big-data/es-05/8.jpg
[9]: /images/big-data/es-05/9.jpg
[10]: /images/big-data/es-05/10.jpg
[11]: /images/big-data/es-05/11.jpg
[12]: /images/big-data/es-05/12.jpg
[13]: /images/big-data/es-05/13.jpg
[14]: /images/big-data/es-05/14.jpg
[15]: /images/big-data/es-05/15.jpg
[16]: /images/big-data/es-05/16.jpg
[17]: /images/big-data/es-05/17.jpg
[18]: /images/big-data/es-05/18.jpg

<style>
  img {
    zoom: 50%;
  }
</style>
